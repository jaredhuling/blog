{
    "collab_server" : "",
    "contents" : "---\ndate: 2017-07-19\ntitle: The oem package for penalized regression is on CRAN\ntags: [R, C++, computational-statistics, machine-learning]\ncategories: [R]\nreferences:\n- id: xiong16\n  title: 'Orthogonalizing EM: A Design-Based Least Squares Algorithm'\n  author:\n  - family: Xiong\n    given: Shifeng\n  - family: Dai\n    given: Bin\n  - family: Huling\n    given: Jared\n  - family: Qian\n    given: Peter Z.G.\n  container-title: Technometrics, in press\n  type: article-journal\n  issued:\n    year: 2016\n---\n\nThe [oem](https://cran.r-project.org/package=oem) package has been on CRAN for some time now, but with the latest update I expect few structural changes to the user interface. `oem` is a package for the estimation of various penalized regression models using the oem algorithm of [Xiong et al. (2016)](http://amstat.tandfonline.com/doi/abs/10.1080/00401706.2015.1054436). The focus of `oem` is to provide high performance computation for big **tall** data. Many applications not only have a large number of variables, but a vast number of observations; `oem` is designed to perform well in these settings.\n\n- Fast computation for big **tall** data\n- Efficient computation for computation for multiple penalties simultaneously\n- Efficient cross-validation \n\nIn this post I'll give a brief overview of what is in the `oem` package and how to use it.\n\n# Installation\n\nThe simplest way to install `oem` is via the CRAN repositories as the following:\n\n```r\ninstall.packages(\"oem\")\n```\n\nTo install the development version, first install the `devtools` package\n\n\n```r\ninstall.packages(\"devtools\")\n```\n\nand then install `oem` via the `install_github` function\n\n```r\ndevtools::install_github(\"jaredhuling/oem\")\n```\n\n\n# Quick Start\n\nFirst load `oem` \n\n\n```r\nlibrary(oem)\n```\n\nSimulate data\n\n\n```r\nnobs  <- 1e4\nnvars <- 100\nx <- matrix(rnorm(nobs * nvars), ncol = nvars)\ny <- drop(x %*% c(0.5, 0.5, -0.5, -0.5, 1, rep(0, nvars - 5))) + rnorm(nobs, sd = 4)\n```\n\n\nFit a penalized regression model using the `oem` function\n\n\n```r\nfit1 <- oem(x = x, y = y, penalty = \"lasso\")\n```\n\nPlot the solution path\n\n\n```r\nplot(fit1)\n```\n\n![center](/images/2017-07-19-oem_cran-unnamed-chunk-7-1.png)\n\n# Key Features\n\n## Available functions\n\n\n|--------------------+-----------------------------------|\n| Function Name      | Functionality                     |\n|====================+===================================|\n| `oem()`            | Main fitting function             |\n|--------------------+-----------------------------------|\n| `predict.oemfit()` | Prediction for oem objects        |\n|--------------------+-----------------------------------|\n| `plot.oemfit()`    | Plotting for oem objects          |\n|--------------------+-----------------------------------|\n| `logLik.oemfit()`  | log Likelihood for oem objects    |\n|--------------------+-----------------------------------|\n| `cv.oem()`         | Cross-validation function         |\n|--------------------+-----------------------------------|\n| `xval.oem()`       | Accelerated cross-validation for linear models         |\n|--------------------+-----------------------------------|\n| `predict.cv.oem()` | Prediction for cv.oem objects     |\n|--------------------+-----------------------------------|\n| `plot.cv.oem()`    | Plotting for cv.oem objects       |\n|--------------------+-----------------------------------|\n| `logLik.cv.oem()`  | log Likelihood for cv.oem objects |\n|--------------------+-----------------------------------|\n\n## Available Penalties\n\n|--------------------+--------------------+--------------------------|\n| Penalty            | Option Name        |  Penalty Form            |\n|====================+===============================================|\n| Lasso              | `lasso`            | $\\lambda \\sum_{j = 1}^pd_j\\vert\\beta_j\\vert$ |\n|--------------------+--------------------+--------------------------|\n| Elastic Net        | `elastic.net`      | $\\lambda \\sum_{j = 1}^p\\alpha d_j\\vert\\beta_j\\vert + (1 - \\alpha)\\lambda \\sum_{j = 1}^pd_j\\beta_j^2$ |\n|--------------------+--------------------+--------------------------|\n| MCP                | `mcp`              | $\\lambda \\sum_{j = 1}^pd_j \\int_0^{\\beta_j}(1 - x/(\\gamma\\lambda d_j))_+\\mathrm{d}x$ |\n|--------------------+--------------------+--------------------------|\n| SCAD               | `scad`             | $\\sum_{j = 1}^p p^{SCAD}_{\\lambda d_j,\\gamma}(\\beta_j)$               |\n|--------------------+--------------------+--------------------------|\n| Group Lasso        | `grp.lasso`        | $\\lambda \\sum_{k = 1}^Gd_k\\sqrt{\\sum_{j \\in g_k}\\beta_j^2}$ |\n|--------------------+--------------------+--------------------------|\n| Group MCP          | `grp.mcp`          | $\\sum_{k = 1}^G p_{\\lambda d_k,\\gamma}^{MCP}\\left(\\vert \\vert \\boldsymbol\\beta_{g_k}\\vert \\vert_2\\right)$ |\n|--------------------+--------------------+--------------------------|\n| Group SCAD         | `grp.scad`         | $\\sum_{k = 1}^G p_{\\lambda d_k,\\gamma}^{SCAD}\\left(\\vert \\vert \\boldsymbol\\beta_{g_k}\\vert \\vert_2\\right)$ |\n|--------------------+--------------------+--------------------------|\n| Sparse Group Lasso | `sparse.grp.lasso` | $\\lambda \\alpha\\sum_{j = 1}^pd_j\\vert\\beta_j\\vert + \\lambda (1-\\alpha)\\sum_{k = 1}^Gd_k\\sqrt{\\sum_{j \\in g_k}\\beta_j^2}$ |\n|--------------------+--------------------+--------------------------|\n\nwhere $\\vert\\vert\\boldsymbol\\beta_{g_k}\\vert\\vert_2 = \\sqrt{\\sum_{j \\in g_k}\\beta_j^2}$.\n\nAny penalty with `.net` at the end of its name has a ridge term of $(1 - \\alpha)\\lambda \\sum_{j = 1}^pd_j\\beta_j^2$ added to it and the original penalty multiplied by $\\alpha$. For example, `grp.mcp.net` is the penalty \n\n$$\\lambda \\sum_{k = 1}^G\\alpha p^{MCP}_{\\lambda d_k,\\gamma}(\\vert\\vert\\boldsymbol\\beta_{g_k}\\vert\\vert_2) + (1 - \\alpha)\\lambda \\sum_{j = 1}^pd_j\\beta_j^2.\n$$\n\n\n## Available Model Families\n\nThe following models are available currently. \n\n|---------------------+--------------------+--------------------------|\n| Model               | Option Name        |  Loss Form               |\n|=====================+===============================================|\n| Linear Regression   | `gaussian`         | $\\frac{1}{2n}\\sum_{i=1}^n(y_i - x_i^T\\beta) ^ 2$ |\n|---------------------+--------------------+--------------------------|\n| Logistic Regression | `binomial`         |  $-\\frac{1}{n}\\sum_{i=1}^n\\left[y_i x_i^T\\beta - \\log (1 + \\exp\\{ x_i^T\\beta \\} ) \\right]$|\n|---------------------+--------------------+--------------------------|\n\nThere are plans to include support for multiple responses, binomial models (not just logistic regression), Cox's proportional hazards model, and more if requested.\n\n# Fitting multiple penalties at once\n\nThe oem algorithm is well-suited to quickly estimate a solution path for multiple penalties simultaneously if the number of variables is not too large. The oem algorithm is only efficient for multiple penalties for linear models. \n\nFor the group lasso penalty, the `groups` argument must be used. `groups` should be a vector which indicates the group number for each variable.\n\n\n```r\nfit2 <- oem(x = x, y = y, penalty = c(\"lasso\", \"mcp\", \"grp.lasso\", \"grp.mcp\"),\n            groups = rep(1:20, each = 5))\n```\n\nPlot the solution paths for all models\n\n\n```r\nlayout(matrix(1:4, ncol = 2))\nplot(fit2, which.model = 1, xvar = \"lambda\")\nplot(fit2, which.model = 2, xvar = \"lambda\")\nplot(fit2, which.model = 3, xvar = \"lambda\")\nplot(fit2, which.model = \"grp.mcp\", xvar = \"lambda\")\n```\n\n![center](/post/2017-07-19-oem_cran_files/2017-07-19-oem_cran-unnamed-chunk-9-1.png)\n\n## Timing Comparison\n\nThe following is a demonstration of oem's efficiency for computing solutions for tuning parameter paths for multiple\npenalties at once.\n\n### Linear Regression\n\nThe efficiency oem for fitting multiple penalties at once only applies to linear models. However, for linear models it is quite efficient, even for a high number of tuning parameters for many different penalties.\n\n\n```r\nnobs  <- 1e5\nnvars <- 100\nx2 <- matrix(rnorm(nobs * nvars), ncol = nvars)\ny2 <- drop(x2 %*% c(0.5, 0.5, -0.5, -0.5, 1, rep(0, nvars - 5))) + rnorm(nobs, sd = 4)\n\nsystem.time(fit2a <- oem(x = x2, y = y2, penalty = c(\"grp.lasso\"),\n                         groups = rep(1:20, each = 5), nlambda = 100L))\n```\n\n```\n##    user  system elapsed \n##    0.23    0.02    0.25\n```\n\n```r\nsystem.time(fit2b <- oem(x = x2, y = y2, \n                         penalty = c(\"grp.lasso\", \"lasso\", \"mcp\", \n                                     \"scad\", \"elastic.net\", \"grp.mcp\",\n                                     \"grp.scad\", \"sparse.grp.lasso\"),\n                         groups = rep(1:20, each = 5), nlambda = 100L))\n```\n\n```\n##    user  system elapsed \n##    0.28    0.02    0.30\n```\n\n```r\nsystem.time(fit2c <- oem(x = x2, y = y2, \n                         penalty = c(\"grp.lasso\", \"lasso\", \"mcp\", \n                                     \"scad\", \"elastic.net\", \"grp.mcp\",\n                                     \"grp.scad\", \"sparse.grp.lasso\"),\n                         groups = rep(1:20, each = 5), nlambda = 500L))\n```\n\n```\n##    user  system elapsed \n##    0.41    0.01    0.42\n```\n\n### Logistic Regression\n\nIt is still more efficient to fit multiple penalties at once instead of individually for logistic regression, but the benefit is not as dramatic as for linear models. \n\n\n```r\nnobs  <- 5e4\nnvars <- 100\nx2 <- matrix(rnorm(nobs * nvars), ncol = nvars)\n\ny2 <- rbinom(nobs, 1, prob = 1 / (1 + exp(-drop(x2 %*% c(0.15, 0.15, -0.15, -0.15, 0.25, rep(0, nvars - 5))))))\n\n\nsystem.time(fit2a <- oem(x = x2, y = y2, penalty = c(\"grp.lasso\"),\n                         family = \"binomial\",\n                         groups = rep(1:20, each = 5), nlambda = 100L))\n```\n\n```\n##    user  system elapsed \n##    2.15    0.00    2.17\n```\n\n```r\nsystem.time(fit2b <- oem(x = x2, y = y2, penalty = c(\"grp.lasso\", \"lasso\", \"mcp\", \"scad\", \"elastic.net\"),\n                         family = \"binomial\",\n                         groups = rep(1:20, each = 5), nlambda = 100L))\n```\n\n```\n##    user  system elapsed \n##   11.23    0.06   11.42\n```\n\n# Cross Validation\n\nHere we use the `nfolds` argument to specify the number of folds for $k$-fold cross validation\n\n\n```r\nsystem.time(cvfit1 <- cv.oem(x = x, y = y, \n                             penalty = c(\"lasso\", \"mcp\", \n                                         \"grp.lasso\", \"grp.mcp\"), \n                             gamma = 2,\n                             groups = rep(1:20, each = 5), \n                             nfolds = 10))\n```\n\n```\n##    user  system elapsed \n##    1.72    0.11    1.83\n```\n\nPlot the cross validation mean squared error results for each model\n\n\n```r\nlayout(matrix(1:4, ncol = 2))\nplot(cvfit1, which.model = 1)\nplot(cvfit1, which.model = 2)\nplot(cvfit1, which.model = 3)\nplot(cvfit1, which.model = 4)\n```\n\n![center](/post/2017-07-19-oem_cran_files/2017-07-19-oem_cran-unnamed-chunk-13-1.png)\n\n## Extremely Fast Cross Validation for Linear Models\n\nThe function `xval.oem` offers accelerated cross validation for penalized linear models. In many cases is is orders of magnitude faster than cv.oem. It is only recommended for scenarios where the number of observations is larger than the number of variables. In addition to the computational gains in single-core usage, it also benefits from parallelizaton using OpenMP (instead of using foreach, as used by cv.oem). For large enough problems, it has on a similar order of computation time as just fitting one OEM model. \n\n\n```r\nnobsc  <- 1e5\nnvarsc <- 100\nxc <- matrix(rnorm(nobsc * nvarsc), ncol = nvarsc)\nyc <- drop(xc %*% c(0.5, 0.5, -0.5, -0.5, 1, rep(0, nvarsc - 5))) + rnorm(nobsc, sd = 4)\n\nsystem.time(cvalfit1 <- cv.oem(x = xc, y = yc, penalty = \"lasso\", \n                               groups = rep(1:20, each = 5), \n                               nfolds = 10))\n```\n\n```\n##    user  system elapsed \n##    6.67    0.77    7.56\n```\n\n```r\nsystem.time(xvalfit1 <- xval.oem(x = xc, y = yc, penalty = \"lasso\",\n                                 groups = rep(1:20, each = 5), \n                                 nfolds = 10))\n```\n\n```\n##    user  system elapsed \n##    0.99    0.05    1.05\n```\n\n```r\nsystem.time(xvalfit2 <- xval.oem(x = xc, y = yc, penalty = \"lasso\",\n                                 groups = rep(1:20, each = 5), \n                                 nfolds = 10, ncores = 2))\n```\n\n```\n##    user  system elapsed \n##    1.39    0.04    0.94\n```\n\n```r\nsystem.time(ofit1 <- oem(x = xc, y = yc, penalty = \"lasso\",\n                         groups = rep(1:20, each = 5)))\n```\n\n```\n##    user  system elapsed \n##    0.20    0.05    0.25\n```\n\n\n## Evaluation Metrics\n\nA variety of evaluation metrics can be used for cross validation. The available metrics can be found in the table below\n\n|-----------------------+------------------------------------+--------------------------|\n| Model                 | Metric                             |  `type.measure=`         |\n|=======================+====================================+==========================|\n| **Linear Regression** | Mean squared error                 |     `mse` or `deviance`  |\n|-----------------------+------------------------------------+--------------------------|\n|                       | Mean absolute error                |     `mae`                |\n|-----------------------+------------------------------------+--------------------------|\n|**Logistic Regression**| Deviance                           |     `deviance`           |\n|-----------------------+------------------------------------+--------------------------|\n|                       | Area under the ROC curve           |     `auc`                |\n|-----------------------+------------------------------------+--------------------------|\n|                       | Misclassification Rate             |     `class`              |\n|-----------------------+------------------------------------+--------------------------|\n|                       | Mean squared error of fitted mean  |     `mse`                |\n|-----------------------+------------------------------------+--------------------------|\n|                       | Mean absolute error of fitted mean |     `mae`                |\n|-----------------------+------------------------------------+--------------------------|\n\nConsider a binary outcome setting with logistic regression. \n\n\n```r\nnobs  <- 2e3\nnvars <- 20\nx <- matrix(runif(nobs * nvars, max = 2), ncol = nvars)\n\ny <- rbinom(nobs, 1, prob = 1 / (1 + exp(-drop(x %*% c(0.25, -1, -1, -0.5, -0.5, -0.25, rep(0, nvars - 6))))))\n```\n\n### Misclassification Rate\n\n\n```r\ncvfit2 <- cv.oem(x = x, y = y, penalty = c(\"lasso\", \"mcp\", \n                                           \"grp.lasso\", \"grp.mcp\"), \n                 family = \"binomial\",\n                 type.measure = \"class\",\n                 gamma = 2,\n                 groups = rep(1:10, each = 2), \n                 nfolds = 10, standardize = FALSE)\n```\n\n![center](/post/2017-07-19-oem_cran_files/2017-07-19-oem_cran-unnamed-chunk-17-1.png)\n\nIn this case, misclassification rate is not the best indicator of performance. The classes here are imbalanced:\n\n```r\nmean(y)\n```\n\n```\n## [1] 0.0685\n```\n\n\n### Area Under the ROC Curve\n\nArea under the ROC curve is an alternative classification metric to misclassification rate. It is available by setting `type.measure = \"auc\"`.\n\n\n```r\ncvfit2 <- cv.oem(x = x, y = y, penalty = c(\"lasso\", \"mcp\", \n                                           \"grp.lasso\", \"grp.mcp\"), \n                 family = \"binomial\",\n                 type.measure = \"auc\",\n                 gamma = 2,\n                 groups = rep(1:10, each = 2), \n                 nfolds = 10, standardize = FALSE)\n```\n\n![center](/post/2017-07-19-oem_cran_files/2017-07-19-oem_cran-unnamed-chunk-20-1.png)\n\n# Methods for Very Large Scale Problems\n\n## OEM with Precomputed $X^TX$, $X^TY$ for Linear Models\n\nWith a very large dataset and computing cluster, the total size of a dataset may be very large, but if the number of variables is only moderately large (on the order of a few thousands) $X^TX$ and $X^TY$ may not be large and may already be available from other computations or can be computed trivially in parallel. The function `oem.xtx` computes penalized linear regression models using the OEM algorithm only using $X^TX$ and $X^TY$. Standardization can be achieved by providing a vector of scaling factors (usually the standard deviations of the columns of x). The function is used like the following:\n\n\n\n\n```r\nxtx <- crossprod(xc) / nrow(xc)\nxty <- crossprod(xc, yc) / nrow(xc)\n\n\nsystem.time(fit <- oem(x = xc, y = yc, \n                       penalty = c(\"lasso\", \"grp.lasso\"), \n                       standardize = FALSE, intercept = FALSE,\n                       groups = rep(1:20, each = 5)))\n```\n\n```\n##    user  system elapsed \n##    0.22    0.04    0.25\n```\n\n```r\nsystem.time(fit.xtx <- oem.xtx(xtx = xtx, xty = xty, \n                               penalty = c(\"lasso\", \"grp.lasso\"), \n                               groups = rep(1:20, each = 5))  )  \n```\n\n```\n##    user  system elapsed \n##    0.01    0.00    0.02\n```\n\n```r\nmax(abs(fit$beta[[1]][-1,] - fit.xtx$beta[[1]]))\n```\n\n```\n## [1] 1.454392e-14\n```\n\n```r\nmax(abs(fit$beta[[2]][-1,] - fit.xtx$beta[[2]])) \n```\n\n```\n## [1] 1.454392e-14\n```\n\n```r\ncol.std <- apply(xc, 2, sd)\nfit.xtx.s <- oem.xtx(xtx = xtx, xty = xty, \n                     scale.factor = col.std,\n                     penalty = c(\"lasso\", \"grp.lasso\"), \n                     groups = rep(1:20, each = 5))  \n```\n\n\n\n## Out-of-memory Computation\n\nThe OEM package also provides functionality for on-disk computation with the `big.oem` function, allowing for fitting penalized regression models on datasets too large to fit in memory. The `big.oem` function uses the tools provided by the `bigmemory` package, so a big.matrix object must be used for the design matrix. \n\n\n```r\nset.seed(123)\nnrows <- 50000\nncols <- 100\nbkFile <- \"bigmat.bk\"\ndescFile <- \"bigmatk.desc\"\nbigmat <- filebacked.big.matrix(nrow=nrows, ncol=ncols, type=\"double\",\n                                backingfile=bkFile, backingpath=\".\",\n                                descriptorfile=descFile,\n                                dimnames=c(NULL,NULL))\n\n# Each column value with be the column number multiplied by\n# samples from a standard normal distribution.\nset.seed(123)\nfor (i in 1:ncols) bigmat[,i] = rnorm(nrows)*i\n\nyb <- rnorm(nrows) + bigmat[,1] - bigmat[,2]\n\n## out-of-memory computation\nfit <- big.oem(x = bigmat, y = yb, \n               penalty = c(\"lasso\", \"grp.lasso\"), \n               groups = rep(1:20, each = 5))\n\n## fitting with in-memory computation\nfit2 <- oem(x = bigmat[,], y = yb, \n            penalty = c(\"lasso\", \"grp.lasso\"), \n            groups = rep(1:20, each = 5))   \n           \nmax(abs(fit$beta[[1]] - fit2$beta[[1]]))            \n```\n\n```\n## [1] 1.534783e-05\n```\n\n# Other Features\n\n## Parallelization via OpenMP\n\nComputational time can be reduced a little via OpenMP parallelization of the key computational steps of the OEM algorithm. Simply use the `ncores` argument to access parallelization. There is no need for the foreach package.\n\n\n```r\nnobsc  <- 1e5\nnvarsc <- 500\nxc <- matrix(rnorm(nobsc * nvarsc), ncol = nvarsc)\nyc <- drop(xc %*% c(0.5, 0.5, -0.5, -0.5, 1, rep(0, nvarsc - 5))) + rnorm(nobsc, sd = 4)\n\n\nsystem.time(fit <- oem(x = xc, y = yc, \n                       penalty = c(\"lasso\", \"grp.lasso\"), \n                       standardize = FALSE, intercept = FALSE,\n                       groups = rep(1:20, each = 25)))\n```\n\n```\n##    user  system elapsed \n##    3.83    0.17    4.52\n```\n\n```r\nsystem.time(fitp <- oem(x = xc, y = yc, \n                        penalty = c(\"lasso\", \"grp.lasso\"), \n                        standardize = FALSE, intercept = FALSE,\n                        groups = rep(1:20, each = 25), ncores = 2))\n```\n\n```\n##    user  system elapsed \n##    5.57    0.14    4.00\n```\n\n## Penalty Adjustment\nIf some variables should not be penalized, this can be specified through the use of the `penalty.factor` argument for all penalties other than the group lasso. For the group lasso, the group-specific weights can be modified by the `group.weights` argument. `penalty.factor` should be a vector of length equal to the number of columns in `x`. Each element in `penalty.factor` will be multiplied to the applied tuning parameter for each corresponding variable. For example, for a problem with 5 variables (`ncol(x) = 5`), setting `penalty.factor = c(1, 1, 1, 0, 0)` will effectively only allow penalization for the first three variables. The `group.weights` argument should be a vector with length equal to the number of groups. Similarly to `penalty.factor`, these weights will be multiplied to the penalty applied to each group. `penalty.factor` and `group.weights` can also be used to fit the adaptive lasso and adaptive group lasso, respectively.  \n\nThe following example shows how to fit an adaptive lasso using `oem`\n\n```r\nnobs  <- 1e4\nnvars <- 102\nx <- matrix(rnorm(nobs * nvars), ncol = nvars)\ny <- drop(x %*% c(0.5, 0.5, -0.5, -0.5, 1, 0.5, rep(0, nvars - 6))) + rnorm(nobs, sd = 4)\n\nlams <- exp(seq(log(2.5), log(5e-5), length.out = 100L))\n\nols.estimates <- coef(lm.fit(y = y, x = cbind(1, x)))[-1]\n\nfit.adaptive <- oem(x = x, y = y, penalty = c(\"lasso\"),\n                    penalty.factor = 1 / abs(ols.estimates),\n                    lambda = lams)\n\ngroup.indicators <- rep(1:34, each = 3)\n\n## norms of OLS estimates for each group\ngroup.norms      <- sapply(1:34, function(idx) sqrt(sum((ols.estimates[group.indicators == idx]) ^ 2)))\nfit.adaptive.grp <- oem(x = x, y = y, penalty = c(\"grp.lasso\"),\n                        group.weights = 1 / group.norms,\n                        groups = group.indicators, \n                        lambda = lams)\n```\n\n![center](/post/2017-07-19-oem_cran_files/2017-07-19-oem_cran-unnamed-chunk-25-1.png)\n\n\n\n# More Information\n\nFor further information about `oem`,\nplease visit:\n\n  * The oem site:        [casualinference.org/oem](http://jaredhuling.github.io/oem)\n  * The oem source code: [github.com/jaredhuling/oem](https://github.com/jaredhuling/oem)\n  * The oem paper:       [oem paper](http://www.tandfonline.com/doi/abs/10.1080/00401706.2015.1054436)\n\n",
    "created" : 1510682792747.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3796346202",
    "id" : "B9316982",
    "lastKnownWriteTime" : 1510685711,
    "last_content_update" : 1510685711791,
    "path" : "~/github/blog/content/post/2017-07-19-oem_cran.md",
    "project_path" : "content/post/2017-07-19-oem_cran.md",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "markdown"
}